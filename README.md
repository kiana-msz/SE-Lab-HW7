## بازآرایی‌ها

**بازآرایی Facade**

دو کلاس CodeGeneratorFacade و ParserFacade جهت اضافه کردن یک واسط برای ارتباط با کلاس‌های Parser و CodeGenerator تعریف شده که به پنهان کردن پیچیدگی‌های درونی و ایجاد یک رابط ساده برای caller ها کمک می‌کند.

**اعمال تکنیک وضعیت/استراتژی یا پلی‌مرفیسم:**
 در کلاس SymbolType که یک enum است، از پلی‌مرفیسم برای مشخص کردن نوع متغیر مرتبط با هر نوع نماد استفاده شد. سپس سوئیچ کیس‌ها با استفاده از symbolType.varType جایگزین شد.

**بازآرایی Separate Query From Modifier**

توابع getTemp و getDateAddress در کلاس Memory همزمان یک فیلد را پرس‌وجو و تغییر می‌دادند. برای حل این موضوع توابع updateTempIndex و updateDataAddress اضافه شدند تا پرس‌وجو از تغییر دهنده جدا شود.

**بازآرایی Self Encapsulated Field Technique**

توابع به عنوان getter برای فیلدهای کلاس Address اضافه شد و از این getterها برای دسترسی به فیلدها در داخل و خارج کلاس استفاده شد.

**دیگر بازآرایی‌ها**
- چهار تابع 
loadRules, initializeParser, shiftAction و reduceAction
را در کلاس Parser با استفاده از بازآرایی Extract Method تفکیک کردیم.

- پارامترهای className و methodName چندین بار به‌طور مشترک استفاده می‌شدند. برای انتقال این پارامترها در SymbolTable، کلاس جدیدی به نام MethodParameters اضافه شد.

## پاسخ سوالات

**سوال ۱**

کد تمیز (Clean Code): کد تمیز به کدی اطلاق می‌شود که خواندن، درک و نگهداری آن آسان باشد.

بدهی فنی (Technical Debt): بدهی فنی به هزینه‌ی تجمعی ناشی از استفاده از راه‌حل‌های کوتاه‌مدت یا اتخاذ تصمیمات طراحی نامطلوب در طول فرآیند توسعه نرم‌افزار اشاره دارد.

بوی بد (Code Smell): بوی بد به نشانه‌هایی در کد اطلاق می‌شود که به مشکلات بالقوه اشاره دارند. این‌ها باگ نیستند، بلکه مناطقی را نشان می‌دهند که ممکن است کد نیاز به بهبود داشته باشد.

**سوال ۲**

افزایش حجم کد (Bloaters): افزایش حجم کد به کدهایی اطلاق می‌شود که به دلیل اندازه یا اجزای تکراری بیش از حد، پیچیده و دشوار برای نگهداری و درک می‌شوند.

سوءاستفاده‌کنندگان از شی‌گرایی (Object-Orientation Abusers): سوءاستفاده‌کنندگان از شی‌گرایی زمانی رخ می‌دهند که توسعه‌دهندگان ویژگی‌های شی‌گرایی را به‌درستی به‌کار نبرده یا کلاس‌های غیرضروری ایجاد می‌کنند که منجر به طراحی ضعیف می‌شود.

مانع‌های تغییر (Change Preventers): موانع تغییر به ساختارهای کدی اطلاق می‌شود که ایجاد تغییر یا گسترش سیستم را دشوار می‌کنند.

موارد غیرضروری (Dispensables): موارد غیرضروری شامل کدهای استفاده‌نشده، بخش‌های کامنت‌شده یا متغیرها/توابع تکراری است که بدون افزودن ارزش به کد، باعث شلوغی آن می‌شوند.

اتصالات زیاد (Couplers): اتصالات زیاد به وابستگی‌های بالا بین کلاس‌ها یا ماژول‌ها اشاره دارد که باعث می‌شود تغییرات در یک مکان، بسیاری از بخش‌های دیگر را تحت تأثیر قرار دهد.

**سوال ۳**

الف) بوی بد Lazy Class در دسته‌بندی Dispensables یا اضافه‌ها قرار می‌گیرد.

ب) برای برطرف کردن این بوی بد کد، می‌توان از تکنیک‌های بازآرایی زیر استفاده کرد:

حذف کلاس: در این تکنیک بررسی می‌کنیم که آیا کلاس تنبل (Lazy Class) هدفی در کد دارد یا خیر و در صورتی که فایده‌ای در کد نداشت، آن را حذف می‌کنیم.

ادغام کلاس: در این کلاس تنبل را با کلاسی که از آن استفاده می‌کند ادغام می‌کنیم.

ج) در برخی موارد ممکن است بوی بد Lazy Class را نادیده بگیریم، زیرا گاهی وجود یک کلاس تنبل در کد می‌تواند منطقی یا موقتی باشد مثلا در صورتی که کلاس در حال توسعه یا تکمیل است، وجود این کلاس از الزامات طراحی معماری است و بخشی از یک الگوی طراحی خاص است و یا حالتی که وجود این کلاس باعث خوانایی و انعطاف‌پذیری کد شود.

**سوال ۴**

۱. استفاده از توابع طولانی: توابع با طول بیشتر از 20-30 خط به عنوان توابع طولانی شناخته می‌شوند. در این پروژه تعداد زیادی تابع با طول بیشتر از 30 خط وجود دارند که قابلیت تبدیل به چند تابع را دارند.

۲. استفاده از کلاس‌های طولانی: برای مثال کلاس Phase2CodeFileManipulator با 576 خط کد، یک کلاس طولانی است.

۳. وجود کد مرده: متدهایی در این پروژه وجود دارند که هیچ جا استفاده نمی‌شوند و به عبارتی مرده هستند و قابلیت حذف شدن از پروژه را دارند.

۴. وجود Refused Bequest: کلاس ValueType و فرزندانش مشکل refused bequest را دارند.

۵. وجود Speculative Generality: بعضی بخش‌های کد برای پشتیبانی از ویژگی‌های پیش‌بینی شده آینده طراحی شده‌اند که هرگز پیاده‌سازی نمی‌شوند.

۶. وجود فیلد موقت: بعضی از فیلدها در بعضی شرایط خاص، مقدار null دارند.

۷. استفاده از switch: این موضوع می‌تواند با الگوی strategy جایگزین شود.

۸. وجود data class: در این پروژه کلاس‌هایی وجود دارند که تنها کلاس داده‌ای هستند و کاربرد دیگری ندارند.

۹. وجود feature envy: در برخی از کلاس‌ها، مشاهده می‌شود که به داده‌ها و متدهای زیادی از کلاس‌های دیگر دسترسی دارند.

۱۰. وجود Inappropriate Intimacy: در بعضی کلاس ها نشانه‌هایی از تعاملات عجیب با سایر کلاس‌ها دیده می‌شود.

**سوال ۵**

پلاگین formatter-maven-plugin به توسعه‌دهندگان این امکان را می‌دهد که کدهای جاوا را با استفاده از Eclipse به‌طور خودکار فرمت کنند. هدف این پلاگین این است که کدها همیشه با یک سبک یکسان نوشته شوند، به طوری که خواندن و نگهداری کد راحت‌تر بشود.
وقتی کدها به طور یکنواخت فرمت شوند، مشکلاتی مثل indentationهای نامناسب یا فاصله‌گذاری‌های غیرقابل‌پیش‌بینی از بین می‌روند. این پلاگین باعث می‌شود که حتی وقتی چند نفر روی یک پروژه کار می‌کنند یا پروژه تغییر می‌کند، همه کدها به یک شکل باشد.
در واقع، این پلاگین کد را به‌طور خودکار بازآرایی می‌کند و این کار را در هنگام ساخت پروژه انجام می‌دهد. به این ترتیب، دیگر نیازی به بازآرایی دستی کدها نیست و در وقت و انرژی صرفه‌جویی می‌شود. این پلاگین می‌تواند در پروژه‌های بزرگ و تیمی خیلی کمک‌کننده باشد، چون همه افراد به یک قالب مشخص برای نوشتن کد پایبند می‌مانند.
